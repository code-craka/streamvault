import { z } from 'zod'

// Base validation schemas
export const videoQualitySchema = z.enum(['480p', '720p', '1080p', '4K'])
export const subscriptionTierSchema = z.enum(['basic', 'premium', 'pro'])
export const streamStatusSchema = z.enum([
  'inactive',
  'active',
  'ended',
  'error',
])
export const vodStatusSchema = z.enum([
  'processing',
  'ready',
  'error',
  'deleted',
])
export const visibilitySchema = z.enum(['public', 'unlisted', 'private'])

// Stream validation schemas
export const streamSettingsSchema = z.object({
  quality: z.array(videoQualitySchema),
  enableChat: z.boolean(),
  enableRecording: z.boolean(),
  isPrivate: z.boolean(),
  requireSubscription: z.boolean(),
  requiredTier: subscriptionTierSchema.optional(),
  moderationLevel: z.enum(['low', 'medium', 'high']),
  allowedCountries: z.array(z.string()).optional(),
  maxDuration: z.number().positive().optional(),
})

export const streamMetadataSchema = z.object({
  thumbnailUrl: z.string().url().optional(),
  previewUrl: z.string().url().optional(),
  language: z.string().optional(),
  ageRating: z.enum(['all', '13+', '18+']).optional(),
  contentWarnings: z.array(z.string()).optional(),
  scheduledStartTime: z.date().optional(),
  estimatedDuration: z.number().positive().optional(),
})

export const createStreamSchema = z.object({
  title: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  category: z.string().optional(),
  tags: z.array(z.string()).max(10),
  settings: streamSettingsSchema,
  metadata: streamMetadataSchema,
})

export const updateStreamSchema = createStreamSchema.partial().extend({
  id: z.string(),
})

export const streamSchema = z.object({
  id: z.string(),
  userId: z.string(),
  title: z.string(),
  description: z.string().optional(),
  category: z.string().optional(),
  tags: z.array(z.string()),
  streamKey: z.string(),
  rtmpUrl: z.string().url(),
  hlsUrl: z.string().url(),
  status: streamStatusSchema,
  isLive: z.boolean(),
  viewerCount: z.number().min(0),
  maxViewers: z.number().min(0),
  startedAt: z.date().optional(),
  endedAt: z.date().optional(),
  createdAt: z.date(),
  updatedAt: z.date(),
  settings: streamSettingsSchema,
  metadata: streamMetadataSchema,
})

// VOD validation schemas
export const subtitleTrackSchema = z.object({
  id: z.string(),
  language: z.string(),
  label: z.string(),
  url: z.string().url(),
  isDefault: z.boolean(),
  isAutoGenerated: z.boolean(),
})

export const chapterSchema = z.object({
  id: z.string(),
  title: z.string(),
  startTime: z.number().min(0),
  endTime: z.number().min(0),
  thumbnailUrl: z.string().url().optional(),
})

export const sceneSchema = z.object({
  id: z.string(),
  startTime: z.number().min(0),
  endTime: z.number().min(0),
  description: z.string(),
  confidence: z.number().min(0).max(1),
  keyFrameUrl: z.string().url().optional(),
})

export const highlightSchema = z.object({
  id: z.string(),
  startTime: z.number().min(0),
  endTime: z.number().min(0),
  title: z.string(),
  description: z.string().optional(),
  confidence: z.number().min(0).max(1),
  thumbnailUrl: z.string().url().optional(),
  clipUrl: z.string().url().optional(),
})

export const aiGeneratedContentSchema = z.object({
  thumbnails: z.array(z.string().url()),
  title: z.string().optional(),
  description: z.string().optional(),
  tags: z.array(z.string()),
  transcription: z.string().optional(),
  scenes: z.array(sceneSchema),
  highlights: z.array(highlightSchema),
  contentScore: z.number().min(0).max(1),
  processedAt: z.date(),
})

export const vodMetadataSchema = z.object({
  originalFileName: z.string().optional(),
  uploadedFileName: z.string(),
  mimeType: z.string(),
  resolution: z.enum(['854x480', '1280x720', '1920x1080', '3840x2160']),
  bitrate: z.number().positive(),
  frameRate: z.number().positive(),
  audioCodec: z.string().optional(),
  videoCodec: z.string().optional(),
  language: z.string().optional(),
  subtitles: z.array(subtitleTrackSchema).optional(),
  chapters: z.array(chapterSchema).optional(),
  aiGenerated: aiGeneratedContentSchema.optional(),
})

export const retentionPointSchema = z.object({
  timestamp: z.number().min(0),
  retentionRate: z.number().min(0).max(1),
})

export const vodAnalyticsSchema = z.object({
  totalViews: z.number().min(0),
  uniqueViews: z.number().min(0),
  averageWatchTime: z.number().min(0),
  completionRate: z.number().min(0).max(1),
  engagementScore: z.number().min(0).max(1),
  geographicDistribution: z.record(z.number()),
  deviceDistribution: z.record(z.number()),
  trafficSources: z.record(z.number()),
  retentionCurve: z.array(retentionPointSchema),
})

export const createVODSchema = z.object({
  title: z.string().min(1).max(100),
  description: z.string().max(1000).optional(),
  category: z.string().optional(),
  tags: z.array(z.string()).max(10),
  visibility: visibilitySchema,
  requiredTier: subscriptionTierSchema,
  streamId: z.string().optional(),
})

export const updateVODSchema = createVODSchema.partial().extend({
  id: z.string(),
})

export const vodSchema = z.object({
  id: z.string(),
  streamId: z.string().optional(),
  userId: z.string(),
  title: z.string(),
  description: z.string().optional(),
  category: z.string().optional(),
  tags: z.array(z.string()),
  duration: z.number().positive(),
  fileSize: z.number().positive(),
  status: vodStatusSchema,
  visibility: visibilitySchema,
  requiredTier: subscriptionTierSchema,
  gcsPath: z.string(),
  thumbnailUrl: z.string().url().optional(),
  previewUrl: z.string().url().optional(),
  viewCount: z.number().min(0),
  likeCount: z.number().min(0),
  createdAt: z.date(),
  updatedAt: z.date(),
  publishedAt: z.date().optional(),
  metadata: vodMetadataSchema,
  analytics: vodAnalyticsSchema,
})

// Transcoding job validation
export const transcodingJobSchema = z.object({
  id: z.string(),
  streamId: z.string().optional(),
  vodId: z.string().optional(),
  inputPath: z.string(),
  outputPath: z.string(),
  status: z.enum(['pending', 'processing', 'completed', 'failed']),
  progress: z.number().min(0).max(100),
  qualities: z.array(videoQualitySchema),
  startedAt: z.date().optional(),
  completedAt: z.date().optional(),
  errorMessage: z.string().optional(),
})

// Query validation schemas
export const streamQuerySchema = z.object({
  userId: z.string().optional(),
  status: streamStatusSchema.optional(),
  category: z.string().optional(),
  isLive: z.boolean().optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  orderBy: z
    .enum(['createdAt', 'updatedAt', 'viewerCount', 'title'])
    .default('createdAt'),
  orderDirection: z.enum(['asc', 'desc']).default('desc'),
})

export const vodQuerySchema = z.object({
  userId: z.string().optional(),
  status: vodStatusSchema.optional(),
  category: z.string().optional(),
  visibility: visibilitySchema.optional(),
  requiredTier: subscriptionTierSchema.optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  orderBy: z
    .enum(['createdAt', 'updatedAt', 'viewCount', 'title', 'duration'])
    .default('createdAt'),
  orderDirection: z.enum(['asc', 'desc']).default('desc'),
  search: z.string().optional(),
})

// Export types inferred from schemas
export type CreateStreamInput = z.infer<typeof createStreamSchema>
export type UpdateStreamInput = z.infer<typeof updateStreamSchema>
export type StreamQueryInput = z.infer<typeof streamQuerySchema>
export type CreateVODInput = z.infer<typeof createVODSchema>
export type UpdateVODInput = z.infer<typeof updateVODSchema>
export type VODQueryInput = z.infer<typeof vodQuerySchema>
export type TranscodingJobInput = z.infer<typeof transcodingJobSchema>
